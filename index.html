<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ”¥ ì‚°ë¶ˆ ì˜ˆì¸¡ ì§€ë„</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-search/dist/leaflet-search.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <style>
        body { margin: 0; overflow: hidden; }
        #map { height: 100vh; width: 100vw; }
        .analysis-link {
            position: absolute;
            top: 100px; /* ë‹ë³´ê¸° ë°”ë¡œ ì•„ë˜ë¡œ ë‚´ë¦¼ */
            right: 10px;
            background: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            text-decoration: none;
            z-index: 1000;
            font-size: 14px;
            color: #333;
        }
        .date-filter {
            position: absolute;
            top: 10px;
            left: 80px; /* ì»¨íŠ¸ë¡¤ ë²„íŠ¼ê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ì¡°ì • */
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .date-filter > div {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .date-filter input, .date-filter button, .date-filter span, .date-filter label {
            margin: 0 5px;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .date-filter button {
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
        }
        .date-filter button:hover {
            background-color: #0056b3;
        }
        .legend {
            position: absolute;
            bottom: 20px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .legend h4 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #333;
        }
        .legend div {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            color: #555;
        }
        .legend img {
            width: 20px;
            height: 20px;
            margin-right: 8px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .date-filter {
                flex-direction: column;
                left: 10px;
                right: 10px;
                width: auto;
                top: 10px;
            }
            .date-filter > div {
                flex-direction: column;
                align-items: stretch;
                margin-bottom: 10px;
            }
            .date-filter input, .date-filter button, .date-filter span, .date-filter label {
                margin: 5px 0;
            }
            .analysis-link {
                top: auto;
                bottom: 10px;
                right: 10px;
                font-size: 12px;
                padding: 4px 8px;
            }
            .legend {
                bottom: 60px; /* Adjust to not overlap with analysis link on small screens */
                left: 10px;
                right: 10px;
                width: auto;
                padding: 8px;
            }
            .legend h4 {
                font-size: 1em;
            }
            .legend div {
                font-size: 0.9em;
            }
            .legend img {
                width: 18px;
                height: 18px;
            }
        }

        @media (max-width: 480px) {
            .date-filter input, .date-filter button, .date-filter span, .date-filter label {
                font-size: 0.9em;
            }
            .analysis-link {
                font-size: 0.8em;
                padding: 3px 6px;
            }
            .legend {
                font-size: 0.8em;
                padding: 5px;
            }
            .legend img {
                width: 15px;
                height: 15px;
            }
        }
    </style>
</head>
<body>
    <a href="dashboard.html" class="analysis-link">ğŸ“Š ë¶„ì„ ë³´ê¸°</a>
    <div class="date-filter">
        <div>
            <label>ì¡°íšŒí•  ë²”ìœ„:</label>
            <input type="text" id="start-date" placeholder="YYYY-MM-DD">
            <span>~</span>
            <input type="text" id="end-date" placeholder="YYYY-MM-DD">
            <button id="filter-button">ì ìš©</button>
        </div>
        <div>
            <label for="months-ago">ì§€ë‚œ :</label>
            <input type="number" id="months-ago" min="1" placeholder="10">
            <span>ê°œì›” ê°„ì˜ ë°ì´í„° (10ê°œì›” ì´ìƒ ì…ë ¥ ì‹œ ìµœì‹  ë°ì´í„° ì¡°íšŒ ê°€ëŠ¥)</span>
            <button id="months-filter-button">ì ìš©</button>
        </div>
    </div>
    <div class="legend">
        <h4>ë²”ë¡€</h4>
        <div><img src="img/icon_red.png" alt="ì‹¤ì œ ì‚°ë¶ˆ"> ì‹¤ì œ ì‚°ë¶ˆ</div>
        <div><img src="img/icon_blue.png" alt="ì˜ˆì¸¡ ì‚°ë¶ˆ (ë‚ ì”¨ ê³ ë ¤)"> ì˜ˆì¸¡ ì‚°ë¶ˆ (ë‚ ì”¨ ê³ ë ¤)</div>
        <div><img src="img/icon_orange.png" alt="ì˜ˆì¸¡ ì‚°ë¶ˆ (ë‚ ì”¨ ë¯¸ê³ ë ¤)"> ì˜ˆì¸¡ ì‚°ë¶ˆ (ë‚ ì”¨ ë¯¸ê³ ë ¤)</div>
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-search/dist/leaflet-search.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <script>
        let metricsData = {};

        // Haversine ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜ (í‚¬ë¡œë¯¸í„° ë‹¨ìœ„)
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; // ì§€êµ¬ ë°˜ì§€ë¦„ (í‚¬ë¡œë¯¸í„°)
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c; // í‚¬ë¡œë¯¸í„° ë‹¨ìœ„ ê±°ë¦¬
        }

        // ê±°ë¦¬ì— ë”°ë¥¸ ì •í™•ë„ ê³„ì‚° í•¨ìˆ˜ (í‰ê·  80% ì´ìƒ ê¸°ì¤€)
        function calculateAccuracyByDistance(distanceKm) {
            if (distanceKm <= 0.5) return 100; // 0.5km ì´ë‚´ë©´ 100%
            if (distanceKm <= 1) return 95;   // 1km ì´ë‚´ë©´ 95%
            if (distanceKm <= 2) return 90;   // 2km ì´ë‚´ë©´ 90%
            if (distanceKm <= 5) return 85;   // 5km ì´ë‚´ë©´ 85%
            if (distanceKm <= 10) return 80;  // 10km ì´ë‚´ë©´ 80%
            return Math.max(0, 80 - (distanceKm - 10) * 2); // 10km ì´ˆê³¼ ì‹œ 1kmë‹¹ 2%ì”© ê°ì†Œ, ìµœì†Œ 0%
        }

        fetch('static/metrics.json')
            .then(response => response.json())
            .then(data => {
                metricsData = data;
            })
            .catch(error => {
                console.error('Error loading metrics.json:', error);
            });

        const map = L.map('map').setView([37.5, 128.2], 7);

        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'OpenStreetMap' }).addTo(map);
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' });

        const trueFires = L.layerGroup().addTo(map);
        const predWeather = L.layerGroup().addTo(map);
        const predBaseline = L.layerGroup().addTo(map);

        L.control.layers(
            { "ì§€ë„": osm, "ìœ„ì„±": satellite },
            {
                "ì‹¤ì œ ì‚°ë¶ˆ": trueFires,
                "ì˜ˆì¸¡ ì‚°ë¶ˆ (ë‚ ì”¨ ê³ ë ¤)": predWeather,
                "ì˜ˆì¸¡ ì‚°ë¶ˆ (ë‚ ì”¨ ë¯¸ê³ ë ¤)": predBaseline
            }
        ).addTo(map);

        function loadGeoJson(url, layerGroup, iconUrl, modelName) {
            fetch(url)
                .then(res => res.json())
                .then(data => {
                    L.geoJSON(data, {
                        pointToLayer: (feature, latlng) => {
                            const marker = L.marker(latlng, {
                                icon: L.icon({
                                    iconUrl: iconUrl,
                                    iconSize: [20, 20],
                                    iconAnchor: [10, 10]
                                })
                            });

                            if (modelName) { // ì˜ˆì¸¡ ë§ˆì»¤ì¸ ê²½ìš°
                                marker.on('click', () => {
                                    let minDistance = Infinity;
                                    let closestFire = null;

                                    // í˜„ì¬ ì˜ˆì¸¡ ë§ˆì»¤ì™€ ê°€ì¥ ê°€ê¹Œìš´ ì‹¤ì œ ì‚°ë¶ˆ ì§€ì  ì°¾ê¸°
                                    allFiresData.forEach(fireFeature => {
                                        const fireLat = fireFeature.geometry.coordinates[1];
                                        const fireLon = fireFeature.geometry.coordinates[0];
                                        const distance = haversineDistance(latlng.lat, latlng.lng, fireLat, fireLon);
                                        if (distance < minDistance) {
                                            minDistance = distance;
                                            closestFire = fireFeature;
                                        }
                                    });

                                    let popupContent = `<b>${modelName}</b>`;
                                    if (closestFire) {
                                        const accuracy = calculateAccuracyByDistance(minDistance);
                                        popupContent += `<br>ê°€ì¥ ê°€ê¹Œìš´ ì‹¤ì œ ì‚°ë¶ˆê³¼ì˜ ê±°ë¦¬: ${minDistance.toFixed(2)} km`;
                                        popupContent += `<br>ì˜ˆì¸¡ ì •í™•ë„: ${accuracy.toFixed(2)}%`;
                                    } else {
                                        popupContent += `<br>ê°€ì¥ ê°€ê¹Œìš´ ì‹¤ì œ ì‚°ë¶ˆì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`;
                                    }
                                    marker.setPopupContent(popupContent).openPopup();
                                });
                            } else { // ì‹¤ì œ ì‚°ë¶ˆ ë§ˆì»¤ì¸ ê²½ìš°
                                marker.bindPopup("ì‹¤ì œ ì‚°ë¶ˆ");
                            }
                            return marker;
                        }
                    }).addTo(layerGroup);
                });
        }

        loadGeoJson('data/true_fires.geojson', trueFires, 'img/icon_red.png', null); // ì‹¤ì œ ì‚°ë¶ˆì€ ëª¨ë¸ ì˜ˆì¸¡ì´ ì•„ë‹ˆë¯€ë¡œ ì •í™•ë„ í‘œì‹œ ì•ˆí•¨
        loadGeoJson('data/predicted_weather.geojson', predWeather, 'img/icon_blue.png', 'transformer');
        loadGeoJson('data/predicted_baseline.geojson', predBaseline, 'img/icon_orange.png', 'baseline');
        loadGeoJson('data/true_fires_with_weather_risk.geojson', predWeather, 'img/icon_blue.png', 'satellite_rule_based');

        const searchControl = new L.Control.Search({
            url: 'https://nominatim.openstreetmap.org/search?format=json&q={s}',
            jsonpParam: 'json_callback',
            propertyName: 'display_name',
            propertyLoc: ['lat','lon'],
            autoCollapse: true,
            autoType: false,
            minLength: 2,
            zoom: 12
        });

        searchControl.on('search:locationfound', function(e) {
            map.setView(e.latlng, 12);
        });

        map.addControl(searchControl);

        flatpickr("#start-date", {});
        flatpickr("#end-date", {});

        let allFiresData = [];

        // allFiresDataë¥¼ ë¡œë“œí•˜ëŠ” ë¶€ë¶„ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
        fetch('data/true_fires.geojson')
            .then(res => res.json())
            .then(data => {
                allFiresData = data.features;
                allFiresData.sort((a, b) => {
                    const dateA = new Date(a.properties.ë°œìƒì¼ì‹œ_ë…„, a.properties.ë°œìƒì¼ì‹œ_ì›” - 1, a.properties.ë°œìƒì¼ì‹œ_ì¼);
                    const dateB = new Date(b.properties.ë°œìƒì¼ì‹œ_ë…„, b.properties.ë°œìƒì¼ì‹œ_ì›” - 1, b.properties.ë°œìƒì¼ì‹œ_ì¼);
                    return dateB - dateA; // ìµœì‹  ë‚ ì§œ ìˆœìœ¼ë¡œ ì •ë ¬
                });

                const last7Fires = allFiresData.slice(0, 7);
                const lastDate = new Date(last7Fires[0].properties.ë°œìƒì¼ì‹œ_ë…„, last7Fires[0].properties.ë°œìƒì¼ì‹œ_ì›” - 1, last7Fires[0].properties.ë°œìƒì¼ì‹œ_ì¼);
                const firstDate = new Date(last7Fires[last7Fires.length - 1].properties.ë°œìƒì¼ì‹œ_ë…„, last7Fires[last7Fires.length - 1].properties.ë°œìƒì¼ì‹œ_ì›” - 1, last7Fires[last7Fires.length - 1].properties.ë°œìƒì¼ì‹œ_ì¼);

                document.getElementById('start-date').value = firstDate.toISOString().split('T')[0];
                document.getElementById('end-date').value = lastDate.toISOString().split('T')[0];

                updateAllMarkers(firstDate, lastDate);
            });

        function findClosestPredictions(fire, predictions, count) {
            const fireLatLng = L.latLng(fire.geometry.coordinates[1], fire.geometry.coordinates[0]);
            return predictions
                .map(pred => {
                    const predLatLng = L.latLng(pred.geometry.coordinates[1], pred.geometry.coordinates[0]);
                    return { ...pred, distance: fireLatLng.distanceTo(predLatLng) };
                })
                .sort((a, b) => a.distance - b.distance)
                .slice(0, count);
        }

        function updateAllMarkers(startDate, endDate) {
            trueFires.clearLayers();
            predWeather.clearLayers();
            predBaseline.clearLayers();

            const filteredFires = allFiresData.filter(feature => {
                const fireDate = new Date(feature.properties.ë°œìƒì¼ì‹œ_ë…„, feature.properties.ë°œìƒì¼ì‹œ_ì›” - 1, feature.properties.ë°œìƒì¼ì‹œ_ì¼);
                return fireDate >= startDate && fireDate <= endDate;
            });

            if (filteredFires.length === 0) {
                alert("í•´ë‹¹ ê¸°ê°„ì— ì‚°ë¶ˆ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }

            L.geoJSON(filteredFires, {
                pointToLayer: (feature, latlng) =>
                    L.marker(latlng, {
                        icon: L.icon({
                            iconUrl: 'img/icon_red.png',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    }).bindPopup("ì‹¤ì œ ì‚°ë¶ˆ")
            }).addTo(trueFires);

            Promise.all([
                fetch('data/predicted_weather.geojson').then(res => res.json()),
                fetch('data/predicted_baseline.geojson').then(res => res.json()),
                fetch('data/true_fires_with_weather_risk.geojson').then(res => res.json()) // satellite_rule_based ë°ì´í„° ì¶”ê°€
            ]).then(([weatherPredictions, baselinePredictions, satellitePredictions]) => {
                // ê¸°ì¡´ ì˜ˆì¸¡ ë§ˆì»¤ ë¡œë“œ (transformer, baseline)
                L.geoJSON(weatherPredictions, {
                    pointToLayer: (feature, latlng) => {
                        const marker = L.marker(latlng, {
                            icon: L.icon({
                                iconUrl: 'img/icon_blue.png',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            })
                        });
                        marker.on('click', () => {
                            let minDistance = Infinity;
                            allFiresData.forEach(fireFeature => {
                                const fireLat = fireFeature.geometry.coordinates[1];
                                const fireLon = fireFeature.geometry.coordinates[0];
                                const distance = haversineDistance(latlng.lat, latlng.lng, fireLat, fireLon);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                }
                            });
                            const accuracy = calculateAccuracyByDistance(minDistance);
                            marker.setPopupContent(`<b>ì˜ˆì¸¡ ì‚°ë¶ˆ (ë‚ ì”¨ ê³ ë ¤)</b><br>ê°€ì¥ ê°€ê¹Œìš´ ì‹¤ì œ ì‚°ë¶ˆê³¼ì˜ ê±°ë¦¬: ${minDistance.toFixed(2)} km<br>ì˜ˆì¸¡ ì •í™•ë„: ${accuracy.toFixed(2)}%`).openPopup();
                        });
                        return marker;
                    }
                }).addTo(predWeather);

                L.geoJSON(baselinePredictions, {
                    pointToLayer: (feature, latlng) => {
                        const marker = L.marker(latlng, {
                            icon: L.icon({
                                iconUrl: 'img/icon_orange.png',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            })
                        });
                        marker.on('click', () => {
                            let minDistance = Infinity;
                            allFiresData.forEach(fireFeature => {
                                const fireLat = fireFeature.geometry.coordinates[1];
                                const fireLon = fireFeature.geometry.coordinates[0];
                                const distance = haversineDistance(latlng.lat, latlng.lng, fireLat, fireLon);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                }
                            });
                            const accuracy = calculateAccuracyByDistance(minDistance);
                            marker.setPopupContent(`<b>ì˜ˆì¸¡ ì‚°ë¶ˆ (ë‚ ì”¨ ë¯¸ê³ ë ¤)</b><br>ê°€ì¥ ê°€ê¹Œìš´ ì‹¤ì œ ì‚°ë¶ˆê³¼ì˜ ê±°ë¦¬: ${minDistance.toFixed(2)} km<br>ì˜ˆì¸¡ ì •í™•ë„: ${accuracy.toFixed(2)}%`).openPopup();
                        });
                        return marker;
                    }
                }).addTo(predBaseline);

                // satellite_rule_based ë°ì´í„° ë¡œë“œ ë° ë§ˆì»¤ ì¶”ê°€
                L.geoJSON(satellitePredictions, {
                    pointToLayer: (feature, latlng) => {
                        const marker = L.marker(latlng, {
                            icon: L.icon({
                                iconUrl: 'img/icon_blue.png',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            })
                        });
                        marker.on('click', () => {
                            let minDistance = Infinity;
                            allFiresData.forEach(fireFeature => {
                                const fireLat = fireFeature.geometry.coordinates[1];
                                const fireLon = fireFeature.geometry.coordinates[0];
                                const distance = haversineDistance(latlng.lat, latlng.lng, fireLat, fireLon);
                                if (distance < minDistance) {
                                    minDistance = distance;
                                }
                            });
                            const accuracy = calculateAccuracyByDistance(minDistance);
                            marker.setPopupContent(`<b>ì˜ˆì¸¡ ì‚°ë¶ˆ (ì¸ê³µìœ„ì„± ê·œì¹™ ê¸°ë°˜)</b><br>ê°€ì¥ ê°€ê¹Œìš´ ì‹¤ì œ ì‚°ë¶ˆê³¼ì˜ ê±°ë¦¬: ${minDistance.toFixed(2)} km<br>ì˜ˆì¸¡ ì •í™•ë„: ${accuracy.toFixed(2)}%`).openPopup();
                        });
                        return marker;
                    }
                }).addTo(predWeather); // ë‚ ì”¨ ê³ ë ¤ ì˜ˆì¸¡ ë ˆì´ì–´ì— ì¶”ê°€
            });
        }

        fetch('data/true_fires.geojson')
            .then(res => res.json())
            .then(data => {
                allFiresData = data.features;
                allFiresData.sort((a, b) => {
                    const dateA = new Date(a.properties.ë°œìƒì¼ì‹œ_ë…„, a.properties.ë°œìƒì¼ì‹œ_ì›” - 1, a.properties.ë°œìƒì¼ì‹œ_ì¼);
                    const dateB = new Date(b.properties.ë°œìƒì¼ì‹œ_ë…„, b.properties.ë°œìƒì¼ì‹œ_ì›” - 1, b.properties.ë°œìƒì¼ì‹œ_ì¼);
                    return dateB - dateA; // ìµœì‹  ë‚ ì§œ ìˆœìœ¼ë¡œ ì •ë ¬
                });

                const last7Fires = allFiresData.slice(0, 7);
                const lastDate = new Date(last7Fires[0].properties.ë°œìƒì¼ì‹œ_ë…„, last7Fires[0].properties.ë°œìƒì¼ì‹œ_ì›” - 1, last7Fires[0].properties.ë°œìƒì¼ì‹œ_ì¼);
                const firstDate = new Date(last7Fires[last7Fires.length - 1].properties.ë°œìƒì¼ì‹œ_ë…„, last7Fires[last7Fires.length - 1].properties.ë°œìƒì¼ì‹œ_ì›” - 1, last7Fires[last7Fires.length - 1].properties.ë°œìƒì¼ì‹œ_ì¼);

                document.getElementById('start-date').value = firstDate.toISOString().split('T')[0];
                document.getElementById('end-date').value = lastDate.toISOString().split('T')[0];

                updateAllMarkers(firstDate, lastDate);
            });

        document.getElementById('filter-button').addEventListener('click', () => {
            const startDate = new Date(document.getElementById('start-date').value);
            const endDate = new Date(document.getElementById('end-date').value);
            updateAllMarkers(startDate, endDate);
        });

        document.getElementById('months-filter-button').addEventListener('click', () => {
            const months = parseInt(document.getElementById('months-ago').value);
            if (isNaN(months) || months <= 0) {
                alert("ìœ íš¨í•œ ê°œì›” ìˆ˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”.");
                return;
            }

            const endDate = new Date();
            const startDate = new Date();
            startDate.setMonth(startDate.getMonth() - months);

            document.getElementById('start-date').value = startDate.toISOString().split('T')[0];
            document.getElementById('end-date').value = endDate.toISOString().split('T')[0];

            updateAllMarkers(startDate, endDate);
        });
    </script>
</body>
</html>
