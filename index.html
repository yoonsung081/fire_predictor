<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>🔥 산불 예측 지도</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-search/dist/leaflet-search.min.css" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <style>
        #map { height: 100vh; }
        .analysis-link {
            position: absolute;
            top: 100px; /* 돋보기 바로 아래로 내림 */
            right: 10px;
            background: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
            text-decoration: none;
            z-index: 1000;
            font-size: 14px;
        }
        .date-filter {
            position: absolute;
            top: 10px;
            left: 50px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <a href="dashboard.html" class="analysis-link">📊 분석 보기</a>
    <div class="date-filter">
        <label for="start-date">시작:</label>
        <input type="text" id="start-date" placeholder="YYYY-MM-DD">
        <label for="end-date">종료:</label>
        <input type="text" id="end-date" placeholder="YYYY-MM-DD">
        <button id="filter-button">적용</button>

        <label for="months-ago">지난:</label>
        <input type="number" id="months-ago" min="1" placeholder="개월">
        <button id="months-filter-button">적용</button>
    </div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-search/dist/leaflet-search.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>

    <script>
        const map = L.map('map').setView([37.5, 128.2], 7);

        const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'OpenStreetMap' }).addTo(map);
        const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri' });

        const trueFires = L.layerGroup().addTo(map);
        const predWeather = L.layerGroup().addTo(map);
        const predBaseline = L.layerGroup().addTo(map);

        L.control.layers(
            { "지도": osm, "위성": satellite },
            {
                "실제 산불": trueFires,
                "날씨 고려 예측": predWeather,
                "날씨 미고려 예측": predBaseline
            }
        ).addTo(map);

        function loadGeoJson(url, layerGroup, iconUrl) {
            fetch(url)
                .then(res => res.json())
                .then(data => {
                    L.geoJSON(data, {
                        pointToLayer: (feature, latlng) =>
                            L.marker(latlng, {
                                icon: L.icon({
                                    iconUrl: iconUrl,
                                    iconSize: [20, 20],
                                    iconAnchor: [10, 10]
                                })
                            })
                    }).addTo(layerGroup);
                });
        }

        loadGeoJson('data/true_fires.geojson', trueFires, 'img/icon_red.png');
        loadGeoJson('data/predicted_weather.geojson', predWeather, 'img/icon_blue.png');
        loadGeoJson('data/predicted_baseline.geojson', predBaseline, 'img/icon_orange.png');

        const searchControl = new L.Control.Search({
            url: 'https://nominatim.openstreetmap.org/search?format=json&q={s}',
            jsonpParam: 'json_callback',
            propertyName: 'display_name',
            propertyLoc: ['lat','lon'],
            autoCollapse: true,
            autoType: false,
            minLength: 2,
            zoom: 12
        });

        searchControl.on('search:locationfound', function(e) {
            map.setView(e.latlng, 12);
        });

        map.addControl(searchControl);

        flatpickr("#start-date", {});
        flatpickr("#end-date", {});

        let allFiresData = [];

        function findClosestPredictions(fire, predictions, count) {
            const fireLatLng = L.latLng(fire.geometry.coordinates[1], fire.geometry.coordinates[0]);
            return predictions
                .map(pred => {
                    const predLatLng = L.latLng(pred.geometry.coordinates[1], pred.geometry.coordinates[0]);
                    return { ...pred, distance: fireLatLng.distanceTo(predLatLng) };
                })
                .sort((a, b) => a.distance - b.distance)
                .slice(0, count);
        }

        function updateAllMarkers(startDate, endDate) {
            trueFires.clearLayers();
            predWeather.clearLayers();
            predBaseline.clearLayers();

            const filteredFires = allFiresData.filter(feature => {
                const fireDate = new Date(feature.properties.발생일시_년, feature.properties.발생일시_월 - 1, feature.properties.발생일시_일);
                return fireDate >= startDate && fireDate <= endDate;
            });

            if (filteredFires.length === 0) {
                alert("해당 기간에 산불 데이터가 없습니다.");
                return;
            }

            L.geoJSON(filteredFires, {
                pointToLayer: (feature, latlng) =>
                    L.marker(latlng, {
                        icon: L.icon({
                            iconUrl: 'img/icon_red.png',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    })
            }).addTo(trueFires);

            Promise.all([
                fetch('data/predicted_weather.geojson').then(res => res.json()),
                fetch('data/predicted_baseline.geojson').then(res => res.json())
            ]).then(([weatherPredictions, baselinePredictions]) => {
                const closestWeather = findClosestPredictions(filteredFires[0], weatherPredictions.features, filteredFires.length);
                const closestBaseline = findClosestPredictions(filteredFires[0], baselinePredictions.features, filteredFires.length);

                L.geoJSON(closestWeather, {
                    pointToLayer: (feature, latlng) =>
                        L.marker(latlng, {
                            icon: L.icon({
                                iconUrl: 'img/icon_blue.png',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            })
                        })
                }).addTo(predWeather);

                L.geoJSON(closestBaseline, {
                    pointToLayer: (feature, latlng) =>
                        L.marker(latlng, {
                            icon: L.icon({
                                iconUrl: 'img/icon_orange.png',
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            })
                        })
                }).addTo(predBaseline);
            });
        }

        fetch('data/true_fires.geojson')
            .then(res => res.json())
            .then(data => {
                allFiresData = data.features;
                allFiresData.sort((a, b) => {
                    const dateA = new Date(a.properties.발생일시_년, a.properties.발생일시_월 - 1, a.properties.발생일시_일);
                    const dateB = new Date(b.properties.발생일시_년, b.properties.발생일시_월 - 1, b.properties.발생일시_일);
                    return dateB - dateA; // 최신 날짜 순으로 정렬
                });

                const last7Fires = allFiresData.slice(0, 7);
                const lastDate = new Date(last7Fires[0].properties.발생일시_년, last7Fires[0].properties.발생일시_월 - 1, last7Fires[0].properties.발생일시_일);
                const firstDate = new Date(last7Fires[last7Fires.length - 1].properties.발생일시_년, last7Fires[last7Fires.length - 1].properties.발생일시_월 - 1, last7Fires[last7Fires.length - 1].properties.발생일시_일);

                document.getElementById('start-date').value = firstDate.toISOString().split('T')[0];
                document.getElementById('end-date').value = lastDate.toISOString().split('T')[0];

                updateAllMarkers(firstDate, lastDate);
            });

        document.getElementById('filter-button').addEventListener('click', () => {
            const startDate = new Date(document.getElementById('start-date').value);
            const endDate = new Date(document.getElementById('end-date').value);
            updateAllMarkers(startDate, endDate);
        });

        document.getElementById('months-filter-button').addEventListener('click', () => {
            const months = parseInt(document.getElementById('months-ago').value);
            if (isNaN(months) || months <= 0) {
                alert("유효한 개월 수를 입력하세요.");
                return;
            }

            const endDate = new Date();
            const startDate = new Date();
            startDate.setMonth(startDate.getMonth() - months);

            document.getElementById('start-date').value = startDate.toISOString().split('T')[0];
            document.getElementById('end-date').value = endDate.toISOString().split('T')[0];

            updateAllMarkers(startDate, endDate);
        });
    </script>
</body>
</html>
